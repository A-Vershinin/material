# Жизненный цикл компонентов в reactjs
> В этом гайде мы будем использовать синтаксис ES6+
> по этому вам уже нужно уметь настроить Webpack + babel

Каждый компонент имеет свой жизненный цикл, когда он только обработался библиотекой, когда он готов для добавления в DOM или когда состояние компонента было изменено. Из прошлого урока мы поняли, что основной метод библиотеки это метод `render()`. Все методы ЖЦ в реакте являются вспомогательными для того, чтобы перехватить данные и обработать их.
####Всего есть 3 состояния компонента
- Добавление(Mounting)
- Обновление(Updating)
- Удаление(Unmounting)

### Методы жизненного цикла

**Mounting: componentWillMount** - Вызывается один раз, на клиенте и сервере, непосредственно перед началом рендеринга. Если вы вызовите setState внутри этого метода, `render()` будет видеть обновленное состояние и будет выполнен только один раз, несмотря на изменение состояния. Является методом инициализации компонента.
```javascript
class Modal extends React.Component {
	componentWillMount() {
		//do something
	}

	render() {
		return (/* render body */);
	}
}		
```

**Mounting: componentDidMount** - Вызывается один раз, только на клиенте (не на сервере), сразу же после того, как происходит инициализация рендеринга. На данном этапе в жизненном цикле компонент имеет представление DOM, к которому вы можете получить доступ, но для этого нужно воспользоваться ссылкой, она обозначается у нужного DOM элемента ввиде атрибута `ref` и элемент становиться доступным в `componentDidMount`. В предыдущем методе ссылки использовать невозможно, так как у него нет представления в DOM.
```javascript
class Modal extends React.Component {
	componentDidMount(argument) {
		console.log( this.refs.myDiv );
	}

	render() {
		return (<div ref="myDiv">Hello</div>);
	}
}		
```

**Updating: componentWillReceiveProps** - Свойство компонента может измениться в любое время, через *родительский компонент*. Когда это происходит вызывается метод `componentWillReceiveProps()` и у вас есть возможность назначить новое свойство и обновить состояние объекта.
Для примера, в нашем простом приложении для опросов есть компонент `AnswerRadioInput` который позволяет пользователям менять состояние radio input. Родительский компонент может менять это булево свойство и мы можем отвечать на это, меняя внутренне состояние, основанное на изменении родительского свойства.
Не хочется раздувать пример применяя композицию. Этот метод используется не столь часто, но является сильной возможностью контролировать свойства компонента.
```javascript
componentWillReceiveProps = (nextProps) => {
  if(nextProps.checked !== undefined) {
    this.setState({
      checked: nextProps.checked
    });
  }
}	
```

> Не существует аналогичного метода componentWillReceiveState. Передача 
> свойств может вызвать изменение состояния, но обратное не верно. Если вам 
> необходимо выполнить операции в ответ на изменение состояния, используйте 
> componentWillUpdate.

**Updating: shouldComponentUpdate** - Вызывается перед рендерингом при получени новых свойств или состояний. Этот метод не вызывается для начального рендеринга или когда используется `forceUpdate`.

Используйте это как возможность `return false`, когда вы уверены, что переход на новые свойства и состояние не потребует обновления компонента.

Если `shouldComponentUpdate` возвращает `false`, то `render()` будет полностью пропускаться до следующего изменения состояния. Кроме того, `componentWillUpdate` и `componentDidUpdate` не будут вызываться.

По умолчанию, `shouldComponentUpdate` всегда возвращает `true`, чтобы предотвратить коварные ошибки, когда state мутирует на месте, но если вы относитесь к state как к неизменному и читатаете только из props и state в `render()`, то вы можете переопределить `shouldComponentUpdate` в реализацию, которая сравнивает старые свойства и состояния с новыми.

Если производительность упадет, особенно с десятками или сотнями компонентов, используйте `shouldComponentUpdate`, чтобы ускорить ваше приложение.
```javascript
shouldComponentUpdate = (nextProps, nextState) => {
  return nextProps.id !== this.props.id;
}	
```

**Updating: componentWillUpdate** - Вызывается перед рендерингом, когда новые свойства или состояния будут получены. Этот метод не вызывается для начала рендеринга.

Используйте этот метод как возможность выполнить подготовку перед обновлением.
Это очень абстрактный пример, но выполнять какие то изменения состояния компонента в этом методе нельзя.
```javascript
componentWillUpdate = (nextProps, nextState) => {
  // отправляем данные на сервер для статистики
  send(nextState);
}	
```
> Вы не можете использовать this.setState() в этом методе. Если вам нужно 
> обновить состояние в ответ на изменение свойства, используйте componentWillReceiveProps.

**Updating: componentDidUpdate** - Вызывается сразу после обновления компонента. Этот метод не вызывается для начала рендеринга.

Используйте этот метод как возможность работать с DOM, когда компонент уже обновлен. Используя все те же refs.
```javascript
componentDidUpdate = (prevProps, prevState) => {
  this.refs.myDiv.classList.add('fadeIn');
}
```

**Unmounting: componentWillUnmount** - Вызывается непосредственно перед тем, как компонент демонтируется из DOM.

Выполняйте любую необходимую очистку в этом методе: отключение таймеров или очистки любых DOM элементов, которые были созданы в componentDidMount.